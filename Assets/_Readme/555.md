要实现大场景的高性能渲染，剔除技术至关重要。下面我为你详细讲解如何实现**视锥剔除**（CPU和GPU方案）和**HZB遮挡剔除**，这是一个从基础到高级的完整优化路径。

## 🎯 剔除技术路线图

首先通过表格了解这三种核心剔除技术的定位和关系：

| 剔除技术 | 执行位置 | 主要目标 | 优势 | 局限性 |
|---------|---------|---------|------|--------|
| **CPU视锥剔除** | CPU端 | 移除摄像机视锥体外的物体 | 基础且高效，减少提交给GPU的数据量 | 无法处理遮挡，CPU负担随物体数量增加 |
| **GPU视锥剔除** | GPU Compute Shader | 更精细的视锥体测试 | 并行处理海量物体，解放CPU | 需要Compute Shader支持 |
| **HZB遮挡剔除** | GPU Compute Shader | 移除被其他物体完全挡住的物体 | 极大减少过度绘制，提升填充率 | 实现复杂，需要生成深度金字塔 |

## 💻 CPU视锥剔除实现

这是最基础的剔除方案，适合物体数量不多或作为第一级粗剔除。

### 核心C#代码
```csharp
using UnityEngine;

public class CPUFrustumCulling : MonoBehaviour
{
    public Camera renderingCamera;
    public Renderer[] allRenderers; // 所有需要剔除的物体
    private Plane[] frustumPlanes;
    
    void Update()
    {
        // 获取摄像机视锥体六个平面
        frustumPlanes = GeometryUtility.CalculateFrustumPlanes(renderingCamera);
        
        foreach (Renderer renderer in allRenderers)
        {
            // 测试物体的包围盒是否在视锥体内
            bool isVisible = GeometryUtility.TestPlanesAABB(frustumPlanes, renderer.bounds);
            renderer.enabled = isVisible;
        }
    }
}
```

### 优化技巧
- **空间分区**：使用四叉树/八叉树先粗粒度剔除整组物体
- **动态静态分离**：静态物体可缓存剔除结果，减少重复计算
- **层次化测试**：先用包围球快速测试，再用AABB精细测试

## 🚀 GPU视锥剔除方案

对于海量物体（如数万植被），CPU剔除会成为瓶颈，此时需要GPU方案。

### 1. 数据准备（C#端）
```csharp
using UnityEngine;

public class GPUFrustumCulling : MonoBehaviour
{
    public ComputeShader frustumCullCS;
    public Mesh instanceMesh;
    public Material instanceMaterial;
    
    private ComputeBuffer _instanceDataBuffer; // 实例数据：位置、缩放等
    private ComputeBuffer _visibleInstanceBuffer; // 可见实例ID
    private ComputeBuffer _argsBuffer; // 间接绘制参数
    private uint[] _args = new uint[5] { 0, 0, 0, 0, 0 };
    
    struct InstanceData
    {
        public Vector3 position;
        public float scale;
        public Vector3 boundsExtents; // AABB包围盒半尺寸
    }
    
    void InitializeGPUCulling()
    {
        // 初始化实例数据（示例）
        InstanceData[] instances = new InstanceData[10000];
        for (int i = 0; i < 10000; i++)
        {
            instances[i] = new InstanceData
            {
                position = Random.insideUnitSphere * 100f,
                scale = Random.Range(0.5f, 2.0f),
                boundsExtents = Vector3.one * 0.5f // 根据实际模型调整
            };
        }
        
        _instanceDataBuffer = new ComputeBuffer(10000, System.Runtime.InteropServices.Marshal.SizeOf(typeof(InstanceData)));
        _instanceDataBuffer.SetData(instances);
        
        _visibleInstanceBuffer = new ComputeBuffer(10000, sizeof(uint), ComputeBufferType.Append);
        _argsBuffer = new ComputeBuffer(1, _args.Length * sizeof(uint), ComputeBufferType.IndirectArguments);
        
        // 设置ComputeShader参数
        frustumCullCS.SetBuffer(0, "_InstanceData", _instanceDataBuffer);
        frustumCullCS.SetBuffer(0, "_VisibleInstances", _visibleInstanceBuffer);
    }
    
    void UpdateFrustumPlanes()
    {
        // 传递视锥体平面数据到ComputeShader
        Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Camera.main);
        Vector4[] planeData = new Vector4[6];
        for (int i = 0; i < 6; i++)
        {
            planeData[i] = new Vector4(planes[i].normal.x, planes[i].normal.y, planes[i].normal.z, planes[i].distance);
        }
        frustumCullCS.SetVectorArray("_FrustumPlanes", planeData);
    }
}
```

### 2. Compute Shader实现
```hlsl
// FrustumCulling.compute
#pragma kernel CSMain

struct InstanceData
{
    float3 position;
    float scale;
    float3 boundsExtents;
};

StructuredBuffer<InstanceData> _InstanceData;
AppendStructuredBuffer<uint> _VisibleInstances;

float4 _FrustumPlanes[6];
int _InstanceCount;

// AABB与视锥体相交测试
bool IsAABBInFrustum(float3 position, float3 extent)
{
    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanes[i];
        float3 absNormal = abs(plane.xyz);
        
        // 计算AABB距离平面的最近点
        float distance = dot(position, plane.xyz) - dot(absNormal, extent);
        if (distance < -plane.w) // 如果最近点都在平面外，则完全不可见
            return false;
    }
    return true;
}

[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _InstanceCount) return;
    
    InstanceData data = _InstanceData[id.x];
    float3 worldPosition = data.position;
    float3 scaledExtent = data.boundsExtents * data.scale;
    
    // 执行视锥体测试
    if (IsAABBInFrustum(worldPosition, scaledExtent))
    {
        _VisibleInstances.Append(id.x);
    }
}
```

### 3. 执行剔除和渲染
```csharp
void Update()
{
    UpdateFrustumPlanes();
    
    // 重置可见实例缓冲区
    _visibleInstanceBuffer.SetCounterValue(0);
    
    // 分派Compute Shader
    int threadGroups = Mathf.CeilToInt(10000f / 64f);
    frustumCullCS.Dispatch(0, threadGroups, 1, 1);
    
    // 更新间接绘制参数
    ComputeBuffer.CopyCount(_visibleInstanceBuffer, _argsBuffer, sizeof(uint));
    _argsBuffer.GetData(_args);
    if (_args[1] == 0) return; // 没有可见实例
    
    // 间接绘制
    Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 200f);
    Graphics.DrawMeshInstancedIndirect(instanceMesh, 0, instanceMaterial, bounds, _argsBuffer);
}
```

## 🔍 HZB遮挡剔除实现

HZB（Hierarchical Z-Buffer）是更高级的剔除技术，能移除被完全遮挡的物体。

### 1. HZB生成和设置
```csharp
public class HZBCulling : MonoBehaviour
{
    private RenderTexture _depthTexture;
    private RenderTexture[] _hizPyramid; // HZB深度金字塔
    private ComputeShader _hizCS;
    
    void GenerateHZB()
    {
        // 生成深度纹理（通常在渲染管线的深度预处理阶段）
        _depthTexture = new RenderTexture(Screen.width, Screen.height, 24, RenderTextureFormat.Depth);
        _depthTexture.Create();
        
        // 构建HZB金字塔
        int width = Screen.width / 2;
        int height = Screen.height / 2;
        int level = 0;
        
        List<RenderTexture> pyramid = new List<RenderTexture>();
        while (width >= 1 || height >= 1)
        {
            RenderTexture rt = new RenderTexture(width, height, 0, RenderTextureFormat.RFloat);
            rt.filterMode = FilterMode.Point;
            rt.Create();
            pyramid.Add(rt);
            
            width = Mathf.Max(1, width / 2);
            height = Mathf.Max(1, height / 2);
            level++;
        }
        _hizPyramid = pyramid.ToArray();
    }
}
```

### 2. HZB测试Compute Shader
```hlsl
// HZBCulling.compute
#pragma kernel HZBTest

Texture2D<float> _HizPyramid;
float4x4 _WorldToViewProject;
float2 _ScreenSize;
int _MaxMipLevel;

// 将世界坐标转换为NDC坐标
float3 WorldToNDC(float3 worldPos)
{
    float4 clipPos = mul(_WorldToViewProject, float4(worldPos, 1.0));
    clipPos.xyz /= clipPos.w;
    float2 uv = clipPos.xy * 0.5 + 0.5;
    return float3(uv, clipPos.z);
}

// HZB遮挡测试
bool IsOccludedByHZB(float3 worldPos, float radius)
{
    float3 ndc = WorldToNDC(worldPos);
    if (ndc.x < 0 || ndc.x > 1 || ndc.y < 0 || ndc.y > 1)
        return true; // 在屏幕外
    
    // 计算物体在屏幕空间的包围盒
    float2 screenPos = ndc.xy * _ScreenSize;
    float2 size = float2(radius * _ScreenSize.x / max(ndc.z, 0.01), 
                         radius * _ScreenSize.y / max(ndc.z, 0.01));
    
    float2 boundsMin = screenPos - size;
    float2 boundsMax = screenPos + size;
    
    // 选择合适HZB mip级别
    float2 boundsSize = boundsMax - boundsMin;
    float maxSize = max(boundsSize.x, boundsSize.y);
    int mip = clamp(ceil(log2(maxSize)), 0, _MaxMipLevel);
    
    // 采样HZB深度
    float2 hizUV = screenPos / (_ScreenSize * exp2(mip));
    float hizDepth = _HizPyramid.mips[mip].SampleLevel(pointClamp, hizUV, 0);
    
    // 深度比较：如果物体最浅深度比HZB深度还大，说明被遮挡
    return ndc.z > hizDepth;
}

[numthreads(64, 1, 1)]
void HZBTest (uint3 id : SV_DispatchThreadID)
{
    // 结合视锥体测试和HZB测试
    // 先进行视锥体测试，通过后再进行HZB测试
}
```

## 🎪 完整的多通道剔除系统

将三种技术结合，形成完整的剔除流水线：

```csharp
public class CompleteCullingSystem : MonoBehaviour
{
    public enum CullingLevel
    {
        CPUOnly = 0,
        GPUFrustum = 1,
        GPUFull = 2 // 包含HZB
    }
    
    public CullingLevel cullingLevel = CullingLevel.GPUFull;
    
    void ExecuteCullingPipeline()
    {
        // 第一级：CPU粗粒度剔除（四叉树/网格分区）
        List<int> coarseVisible = CPUCoarseCulling();
        
        // 第二级：GPU视锥体剔除
        if (cullingLevel >= CullingLevel.GPUFrustum)
        {
            coarseVisible = GPUFrustumCulling(coarseVisible);
        }
        
        // 第三级：HZB遮挡剔除
        if (cullingLevel >= CullingLevel.GPUFull)
        {
            coarseVisible = HZBCulling(coarseVisible);
        }
        
        // 最终渲染
        RenderVisibleInstances(coarseVisible);
    }
}
```

## ⚙️ 性能优化建议

1. **分级细化**：先用粗粒度剔除（四叉树），再用细粒度剔除
2. **异步处理**：将剔除计算分散到多帧，避免单帧峰值
3. **LOD结合**：根据距离使用不同精度的包围盒测试
4. **平台适配**：移动端可适当降低剔除精度或使用简化算法

## 💎 总结

通过CPU视锥剔除、GPU视锥剔除和HZB遮挡剔除的三级流水线，你可以构建出能够处理数百万级物体的大场景渲染系统。建议先从CPU方案开始，逐步集成GPU方案，最后加入HZB高级特性。

希望这份详细的实现指南对你有帮助！如果你在具体实现过程中遇到任何问题，欢迎继续讨论。