è¦å®ç°å¤§åœºæ™¯çš„é«˜æ€§èƒ½æ¸²æŸ“ï¼Œå‰”é™¤æŠ€æœ¯è‡³å…³é‡è¦ã€‚ä¸‹é¢æˆ‘ä¸ºä½ è¯¦ç»†è®²è§£å¦‚ä½•å®ç°**è§†é”¥å‰”é™¤**ï¼ˆCPUå’ŒGPUæ–¹æ¡ˆï¼‰å’Œ**HZBé®æŒ¡å‰”é™¤**ï¼Œè¿™æ˜¯ä¸€ä¸ªä»åŸºç¡€åˆ°é«˜çº§çš„å®Œæ•´ä¼˜åŒ–è·¯å¾„ã€‚

## ğŸ¯ å‰”é™¤æŠ€æœ¯è·¯çº¿å›¾

é¦–å…ˆé€šè¿‡è¡¨æ ¼äº†è§£è¿™ä¸‰ç§æ ¸å¿ƒå‰”é™¤æŠ€æœ¯çš„å®šä½å’Œå…³ç³»ï¼š

| å‰”é™¤æŠ€æœ¯ | æ‰§è¡Œä½ç½® | ä¸»è¦ç›®æ ‡ | ä¼˜åŠ¿ | å±€é™æ€§ |
|---------|---------|---------|------|--------|
| **CPUè§†é”¥å‰”é™¤** | CPUç«¯ | ç§»é™¤æ‘„åƒæœºè§†é”¥ä½“å¤–çš„ç‰©ä½“ | åŸºç¡€ä¸”é«˜æ•ˆï¼Œå‡å°‘æäº¤ç»™GPUçš„æ•°æ®é‡ | æ— æ³•å¤„ç†é®æŒ¡ï¼ŒCPUè´Ÿæ‹…éšç‰©ä½“æ•°é‡å¢åŠ  |
| **GPUè§†é”¥å‰”é™¤** | GPU Compute Shader | æ›´ç²¾ç»†çš„è§†é”¥ä½“æµ‹è¯• | å¹¶è¡Œå¤„ç†æµ·é‡ç‰©ä½“ï¼Œè§£æ”¾CPU | éœ€è¦Compute Shaderæ”¯æŒ |
| **HZBé®æŒ¡å‰”é™¤** | GPU Compute Shader | ç§»é™¤è¢«å…¶ä»–ç‰©ä½“å®Œå…¨æŒ¡ä½çš„ç‰©ä½“ | æå¤§å‡å°‘è¿‡åº¦ç»˜åˆ¶ï¼Œæå‡å¡«å……ç‡ | å®ç°å¤æ‚ï¼Œéœ€è¦ç”Ÿæˆæ·±åº¦é‡‘å­—å¡” |

## ğŸ’» CPUè§†é”¥å‰”é™¤å®ç°

è¿™æ˜¯æœ€åŸºç¡€çš„å‰”é™¤æ–¹æ¡ˆï¼Œé€‚åˆç‰©ä½“æ•°é‡ä¸å¤šæˆ–ä½œä¸ºç¬¬ä¸€çº§ç²—å‰”é™¤ã€‚

### æ ¸å¿ƒC#ä»£ç 
```csharp
using UnityEngine;

public class CPUFrustumCulling : MonoBehaviour
{
    public Camera renderingCamera;
    public Renderer[] allRenderers; // æ‰€æœ‰éœ€è¦å‰”é™¤çš„ç‰©ä½“
    private Plane[] frustumPlanes;
    
    void Update()
    {
        // è·å–æ‘„åƒæœºè§†é”¥ä½“å…­ä¸ªå¹³é¢
        frustumPlanes = GeometryUtility.CalculateFrustumPlanes(renderingCamera);
        
        foreach (Renderer renderer in allRenderers)
        {
            // æµ‹è¯•ç‰©ä½“çš„åŒ…å›´ç›’æ˜¯å¦åœ¨è§†é”¥ä½“å†…
            bool isVisible = GeometryUtility.TestPlanesAABB(frustumPlanes, renderer.bounds);
            renderer.enabled = isVisible;
        }
    }
}
```

### ä¼˜åŒ–æŠ€å·§
- **ç©ºé—´åˆ†åŒº**ï¼šä½¿ç”¨å››å‰æ ‘/å…«å‰æ ‘å…ˆç²—ç²’åº¦å‰”é™¤æ•´ç»„ç‰©ä½“
- **åŠ¨æ€é™æ€åˆ†ç¦»**ï¼šé™æ€ç‰©ä½“å¯ç¼“å­˜å‰”é™¤ç»“æœï¼Œå‡å°‘é‡å¤è®¡ç®—
- **å±‚æ¬¡åŒ–æµ‹è¯•**ï¼šå…ˆç”¨åŒ…å›´çƒå¿«é€Ÿæµ‹è¯•ï¼Œå†ç”¨AABBç²¾ç»†æµ‹è¯•

## ğŸš€ GPUè§†é”¥å‰”é™¤æ–¹æ¡ˆ

å¯¹äºæµ·é‡ç‰©ä½“ï¼ˆå¦‚æ•°ä¸‡æ¤è¢«ï¼‰ï¼ŒCPUå‰”é™¤ä¼šæˆä¸ºç“¶é¢ˆï¼Œæ­¤æ—¶éœ€è¦GPUæ–¹æ¡ˆã€‚

### 1. æ•°æ®å‡†å¤‡ï¼ˆC#ç«¯ï¼‰
```csharp
using UnityEngine;

public class GPUFrustumCulling : MonoBehaviour
{
    public ComputeShader frustumCullCS;
    public Mesh instanceMesh;
    public Material instanceMaterial;
    
    private ComputeBuffer _instanceDataBuffer; // å®ä¾‹æ•°æ®ï¼šä½ç½®ã€ç¼©æ”¾ç­‰
    private ComputeBuffer _visibleInstanceBuffer; // å¯è§å®ä¾‹ID
    private ComputeBuffer _argsBuffer; // é—´æ¥ç»˜åˆ¶å‚æ•°
    private uint[] _args = new uint[5] { 0, 0, 0, 0, 0 };
    
    struct InstanceData
    {
        public Vector3 position;
        public float scale;
        public Vector3 boundsExtents; // AABBåŒ…å›´ç›’åŠå°ºå¯¸
    }
    
    void InitializeGPUCulling()
    {
        // åˆå§‹åŒ–å®ä¾‹æ•°æ®ï¼ˆç¤ºä¾‹ï¼‰
        InstanceData[] instances = new InstanceData[10000];
        for (int i = 0; i < 10000; i++)
        {
            instances[i] = new InstanceData
            {
                position = Random.insideUnitSphere * 100f,
                scale = Random.Range(0.5f, 2.0f),
                boundsExtents = Vector3.one * 0.5f // æ ¹æ®å®é™…æ¨¡å‹è°ƒæ•´
            };
        }
        
        _instanceDataBuffer = new ComputeBuffer(10000, System.Runtime.InteropServices.Marshal.SizeOf(typeof(InstanceData)));
        _instanceDataBuffer.SetData(instances);
        
        _visibleInstanceBuffer = new ComputeBuffer(10000, sizeof(uint), ComputeBufferType.Append);
        _argsBuffer = new ComputeBuffer(1, _args.Length * sizeof(uint), ComputeBufferType.IndirectArguments);
        
        // è®¾ç½®ComputeShaderå‚æ•°
        frustumCullCS.SetBuffer(0, "_InstanceData", _instanceDataBuffer);
        frustumCullCS.SetBuffer(0, "_VisibleInstances", _visibleInstanceBuffer);
    }
    
    void UpdateFrustumPlanes()
    {
        // ä¼ é€’è§†é”¥ä½“å¹³é¢æ•°æ®åˆ°ComputeShader
        Plane[] planes = GeometryUtility.CalculateFrustumPlanes(Camera.main);
        Vector4[] planeData = new Vector4[6];
        for (int i = 0; i < 6; i++)
        {
            planeData[i] = new Vector4(planes[i].normal.x, planes[i].normal.y, planes[i].normal.z, planes[i].distance);
        }
        frustumCullCS.SetVectorArray("_FrustumPlanes", planeData);
    }
}
```

### 2. Compute Shaderå®ç°
```hlsl
// FrustumCulling.compute
#pragma kernel CSMain

struct InstanceData
{
    float3 position;
    float scale;
    float3 boundsExtents;
};

StructuredBuffer<InstanceData> _InstanceData;
AppendStructuredBuffer<uint> _VisibleInstances;

float4 _FrustumPlanes[6];
int _InstanceCount;

// AABBä¸è§†é”¥ä½“ç›¸äº¤æµ‹è¯•
bool IsAABBInFrustum(float3 position, float3 extent)
{
    for (int i = 0; i < 6; i++)
    {
        float4 plane = _FrustumPlanes[i];
        float3 absNormal = abs(plane.xyz);
        
        // è®¡ç®—AABBè·ç¦»å¹³é¢çš„æœ€è¿‘ç‚¹
        float distance = dot(position, plane.xyz) - dot(absNormal, extent);
        if (distance < -plane.w) // å¦‚æœæœ€è¿‘ç‚¹éƒ½åœ¨å¹³é¢å¤–ï¼Œåˆ™å®Œå…¨ä¸å¯è§
            return false;
    }
    return true;
}

[numthreads(64, 1, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _InstanceCount) return;
    
    InstanceData data = _InstanceData[id.x];
    float3 worldPosition = data.position;
    float3 scaledExtent = data.boundsExtents * data.scale;
    
    // æ‰§è¡Œè§†é”¥ä½“æµ‹è¯•
    if (IsAABBInFrustum(worldPosition, scaledExtent))
    {
        _VisibleInstances.Append(id.x);
    }
}
```

### 3. æ‰§è¡Œå‰”é™¤å’Œæ¸²æŸ“
```csharp
void Update()
{
    UpdateFrustumPlanes();
    
    // é‡ç½®å¯è§å®ä¾‹ç¼“å†²åŒº
    _visibleInstanceBuffer.SetCounterValue(0);
    
    // åˆ†æ´¾Compute Shader
    int threadGroups = Mathf.CeilToInt(10000f / 64f);
    frustumCullCS.Dispatch(0, threadGroups, 1, 1);
    
    // æ›´æ–°é—´æ¥ç»˜åˆ¶å‚æ•°
    ComputeBuffer.CopyCount(_visibleInstanceBuffer, _argsBuffer, sizeof(uint));
    _argsBuffer.GetData(_args);
    if (_args[1] == 0) return; // æ²¡æœ‰å¯è§å®ä¾‹
    
    // é—´æ¥ç»˜åˆ¶
    Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 200f);
    Graphics.DrawMeshInstancedIndirect(instanceMesh, 0, instanceMaterial, bounds, _argsBuffer);
}
```

## ğŸ” HZBé®æŒ¡å‰”é™¤å®ç°

HZBï¼ˆHierarchical Z-Bufferï¼‰æ˜¯æ›´é«˜çº§çš„å‰”é™¤æŠ€æœ¯ï¼Œèƒ½ç§»é™¤è¢«å®Œå…¨é®æŒ¡çš„ç‰©ä½“ã€‚

### 1. HZBç”Ÿæˆå’Œè®¾ç½®
```csharp
public class HZBCulling : MonoBehaviour
{
    private RenderTexture _depthTexture;
    private RenderTexture[] _hizPyramid; // HZBæ·±åº¦é‡‘å­—å¡”
    private ComputeShader _hizCS;
    
    void GenerateHZB()
    {
        // ç”Ÿæˆæ·±åº¦çº¹ç†ï¼ˆé€šå¸¸åœ¨æ¸²æŸ“ç®¡çº¿çš„æ·±åº¦é¢„å¤„ç†é˜¶æ®µï¼‰
        _depthTexture = new RenderTexture(Screen.width, Screen.height, 24, RenderTextureFormat.Depth);
        _depthTexture.Create();
        
        // æ„å»ºHZBé‡‘å­—å¡”
        int width = Screen.width / 2;
        int height = Screen.height / 2;
        int level = 0;
        
        List<RenderTexture> pyramid = new List<RenderTexture>();
        while (width >= 1 || height >= 1)
        {
            RenderTexture rt = new RenderTexture(width, height, 0, RenderTextureFormat.RFloat);
            rt.filterMode = FilterMode.Point;
            rt.Create();
            pyramid.Add(rt);
            
            width = Mathf.Max(1, width / 2);
            height = Mathf.Max(1, height / 2);
            level++;
        }
        _hizPyramid = pyramid.ToArray();
    }
}
```

### 2. HZBæµ‹è¯•Compute Shader
```hlsl
// HZBCulling.compute
#pragma kernel HZBTest

Texture2D<float> _HizPyramid;
float4x4 _WorldToViewProject;
float2 _ScreenSize;
int _MaxMipLevel;

// å°†ä¸–ç•Œåæ ‡è½¬æ¢ä¸ºNDCåæ ‡
float3 WorldToNDC(float3 worldPos)
{
    float4 clipPos = mul(_WorldToViewProject, float4(worldPos, 1.0));
    clipPos.xyz /= clipPos.w;
    float2 uv = clipPos.xy * 0.5 + 0.5;
    return float3(uv, clipPos.z);
}

// HZBé®æŒ¡æµ‹è¯•
bool IsOccludedByHZB(float3 worldPos, float radius)
{
    float3 ndc = WorldToNDC(worldPos);
    if (ndc.x < 0 || ndc.x > 1 || ndc.y < 0 || ndc.y > 1)
        return true; // åœ¨å±å¹•å¤–
    
    // è®¡ç®—ç‰©ä½“åœ¨å±å¹•ç©ºé—´çš„åŒ…å›´ç›’
    float2 screenPos = ndc.xy * _ScreenSize;
    float2 size = float2(radius * _ScreenSize.x / max(ndc.z, 0.01), 
                         radius * _ScreenSize.y / max(ndc.z, 0.01));
    
    float2 boundsMin = screenPos - size;
    float2 boundsMax = screenPos + size;
    
    // é€‰æ‹©åˆé€‚HZB mipçº§åˆ«
    float2 boundsSize = boundsMax - boundsMin;
    float maxSize = max(boundsSize.x, boundsSize.y);
    int mip = clamp(ceil(log2(maxSize)), 0, _MaxMipLevel);
    
    // é‡‡æ ·HZBæ·±åº¦
    float2 hizUV = screenPos / (_ScreenSize * exp2(mip));
    float hizDepth = _HizPyramid.mips[mip].SampleLevel(pointClamp, hizUV, 0);
    
    // æ·±åº¦æ¯”è¾ƒï¼šå¦‚æœç‰©ä½“æœ€æµ…æ·±åº¦æ¯”HZBæ·±åº¦è¿˜å¤§ï¼Œè¯´æ˜è¢«é®æŒ¡
    return ndc.z > hizDepth;
}

[numthreads(64, 1, 1)]
void HZBTest (uint3 id : SV_DispatchThreadID)
{
    // ç»“åˆè§†é”¥ä½“æµ‹è¯•å’ŒHZBæµ‹è¯•
    // å…ˆè¿›è¡Œè§†é”¥ä½“æµ‹è¯•ï¼Œé€šè¿‡åå†è¿›è¡ŒHZBæµ‹è¯•
}
```

## ğŸª å®Œæ•´çš„å¤šé€šé“å‰”é™¤ç³»ç»Ÿ

å°†ä¸‰ç§æŠ€æœ¯ç»“åˆï¼Œå½¢æˆå®Œæ•´çš„å‰”é™¤æµæ°´çº¿ï¼š

```csharp
public class CompleteCullingSystem : MonoBehaviour
{
    public enum CullingLevel
    {
        CPUOnly = 0,
        GPUFrustum = 1,
        GPUFull = 2 // åŒ…å«HZB
    }
    
    public CullingLevel cullingLevel = CullingLevel.GPUFull;
    
    void ExecuteCullingPipeline()
    {
        // ç¬¬ä¸€çº§ï¼šCPUç²—ç²’åº¦å‰”é™¤ï¼ˆå››å‰æ ‘/ç½‘æ ¼åˆ†åŒºï¼‰
        List<int> coarseVisible = CPUCoarseCulling();
        
        // ç¬¬äºŒçº§ï¼šGPUè§†é”¥ä½“å‰”é™¤
        if (cullingLevel >= CullingLevel.GPUFrustum)
        {
            coarseVisible = GPUFrustumCulling(coarseVisible);
        }
        
        // ç¬¬ä¸‰çº§ï¼šHZBé®æŒ¡å‰”é™¤
        if (cullingLevel >= CullingLevel.GPUFull)
        {
            coarseVisible = HZBCulling(coarseVisible);
        }
        
        // æœ€ç»ˆæ¸²æŸ“
        RenderVisibleInstances(coarseVisible);
    }
}
```

## âš™ï¸ æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆ†çº§ç»†åŒ–**ï¼šå…ˆç”¨ç²—ç²’åº¦å‰”é™¤ï¼ˆå››å‰æ ‘ï¼‰ï¼Œå†ç”¨ç»†ç²’åº¦å‰”é™¤
2. **å¼‚æ­¥å¤„ç†**ï¼šå°†å‰”é™¤è®¡ç®—åˆ†æ•£åˆ°å¤šå¸§ï¼Œé¿å…å•å¸§å³°å€¼
3. **LODç»“åˆ**ï¼šæ ¹æ®è·ç¦»ä½¿ç”¨ä¸åŒç²¾åº¦çš„åŒ…å›´ç›’æµ‹è¯•
4. **å¹³å°é€‚é…**ï¼šç§»åŠ¨ç«¯å¯é€‚å½“é™ä½å‰”é™¤ç²¾åº¦æˆ–ä½¿ç”¨ç®€åŒ–ç®—æ³•

## ğŸ’ æ€»ç»“

é€šè¿‡CPUè§†é”¥å‰”é™¤ã€GPUè§†é”¥å‰”é™¤å’ŒHZBé®æŒ¡å‰”é™¤çš„ä¸‰çº§æµæ°´çº¿ï¼Œä½ å¯ä»¥æ„å»ºå‡ºèƒ½å¤Ÿå¤„ç†æ•°ç™¾ä¸‡çº§ç‰©ä½“çš„å¤§åœºæ™¯æ¸²æŸ“ç³»ç»Ÿã€‚å»ºè®®å…ˆä»CPUæ–¹æ¡ˆå¼€å§‹ï¼Œé€æ­¥é›†æˆGPUæ–¹æ¡ˆï¼Œæœ€ååŠ å…¥HZBé«˜çº§ç‰¹æ€§ã€‚

å¸Œæœ›è¿™ä»½è¯¦ç»†çš„å®ç°æŒ‡å—å¯¹ä½ æœ‰å¸®åŠ©ï¼å¦‚æœä½ åœ¨å…·ä½“å®ç°è¿‡ç¨‹ä¸­é‡åˆ°ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿ç»§ç»­è®¨è®ºã€‚